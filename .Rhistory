library(leaflet)
library(scales)
library(kableExtra)
incomplete_properties <- read_csv("data/output/incomplete_properties.csv", show_col_types = FALSE)
unassigned_addresses <- read_csv("data/output/unassigned_addresses.csv", show_col_types = FALSE)
shared_addresses <- read_csv("data/output/shared_addresses.csv", show_col_types = FALSE)
problem_matrix <- read_csv("data/output/problem_matrix_comprehensive.csv", show_col_types = FALSE)
total_props <- nrow(property_profile)
property_profile <- read_csv("data/output/verep_full_analysis.csv", show_col_types = FALSE)
attendance_context <- read_csv("data/output/verep_attendance_summary.csv", show_col_types = FALSE)
opportunity_matrix <- read_csv("data/output/verep_opportunity_matrix.csv", show_col_types = FALSE)
leadership_report <- read_csv("data/output/verep_top_opportunities.csv", show_col_types = FALSE)
data_followup <- read_csv("data/output/verep_data_needed.csv", show_col_types = FALSE)
total_props <- nrow(property_profile)
incomplete_data <- nrow(incomplete_properties)
missing_addresses <- sum(unassigned_addresses$num_unassigned)
summary_stats <- tibble(
Metric = c("Total properties analyzed",
"Properties with incomplete data",
"Properties with missing/unassigned addresses"),
Value = c(total_props,
paste0(incomplete_data, " (", round(incomplete_data/total_props*100, 1), "%)"),
missing_addresses)
)
missing_breakdown <- incomplete_properties |>
summarise(
missing_land_value = sum(missing_land_value),
missing_acreage = sum(missing_acreage),
missing_wetland = sum(missing_wetland),
missing_flood = sum(missing_flood),
missing_qct = sum(missing_qct),
missing_zoning = sum(missing_zoning)
) |>
pivot_longer(everything(), names_to = "data_type", values_to = "count") |>
mutate(
data_type = str_remove(data_type, "missing_"),
data_type = str_to_title(str_replace_all(data_type, "_", " "))
) |>
arrange(desc(count))
address_issues <- incomplete_properties |>
filter(
!is.na(property_address) & property_address %in% c("", "INCOMPLETE") |  # incomplete addresses
property_address %in% shared_addresses$property_address |  # shared addresses
pin %in% unassigned_addresses$pin  # missing/unassigned addresses
) |>
nrow()
names(incomplete_properties)
View(incomplete_properties)
glimpse(incomplete_data)
names(incomplete)
names(incomplete_data)
colnames(incomplete_data)
incomplete_properties <- read_csv("data/output/incomplete_properties.csv", show_col_types = FALSE)
View(incomplete_properties)
View(property_profile)
View(incomplete_properties)
address_issues <- nrow(shared_addresses) + nrow(unassigned_addresses) +
nrow(incomplete_properties %>% filter(is.na(sadd) | sadd == ""))
missing_breakdown <- missing_breakdown %>%
add_row(
data_type = "Property Information",
count = address_issues
) %>%
arrange(desc(count))
ggplot(missing_breakdown, aes(x = reorder(data_type, count), y = count)) +
geom_col(fill = "#e76f52", alpha = 0.8) +
geom_text(aes(label = count), hjust = -0.2, size = 4) +
coord_flip() +
labs(
title = "Missing Data by Category",
x = "",
y = "Number of Properties"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", color = "#445ca9"),
panel.grid.major.y = element_blank()
)
shared_props <- sum(shared_addresses$num)
View(shared_addresses)
shared_props <- sum(shared_addresses)
ggplot(missing_breakdown, aes(x = reorder(data_type, count), y = count)) +
geom_col(fill = "#e76f52", alpha = 0.8) +
geom_text(aes(label = count), hjust = -0.2, size = 4) +
coord_flip() +
labs(
title = "Missing Data by Category",
x = "",
y = "Number of Properties"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", color = "#445ca9"),
panel.grid.major.y = element_blank()
)
ggplot(missing_breakdown, aes(x = reorder(data_type, count), y = count)) +
geom_col(fill = "#e76f52", alpha = 0.8) +
geom_text(aes(label = count), hjust = -0.2, size = 4) +
coord_flip() +
labs(
title = "Missing Data by Category",
x = "",
y = "Number of Properties"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", color = "#445ca9"),
panel.grid.major.y = element_blank()
)
ggplot(missing_breakdown, aes(x = reorder(data_type, count), y = count)) +
geom_col(fill = "#e76f52", alpha = 0.8) +
geom_text(aes(label = count), hjust = -0.2, size = 4) +
coord_flip() +
labs(
title = "Missing Data by Category",
x = "",
y = "Number of Properties"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", color = "#445ca9"),
panel.grid.major.y = element_blank()
)
ggplot(missing_breakdown, aes(x = reorder(data_type, count), y = count)) +
geom_col(fill = "#e76f52", alpha = 0.8) +
geom_text(aes(label = count), hjust = -0.2, size = 4) +
coord_flip() +
labs(
title = "Missing Data by Category",
x = "",
y = "Number of Properties"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold", color = "#445ca9"),
panel.grid.major.y = element_blank()
)
ggplot(missing_breakdown, aes(x = reorder(data_type, count), y = count)) +
geom_col(fill = "#e76f52", alpha = 0.8) +
geom_text(aes(label = count), hjust = -0.2, size = 4) +
coord_flip() +
labs(
title = "Missing Data by Category",
x = "",
y = "Number of Properties"
ggplot(missing_breakdown, aes(x = reorder(data_type, count), y = count)) +
colnames(unassigned_addresses)
library(tidygeocoder)
needs_geocoding <- unassigned_addresses %>%
filter(has_coords == 1)
geocoded_results <- needs_geocoding %>%
reverse_geocode(
lat = sample_lat,
long = sample_lon,
method = "osm",        # OpenStreetMap (free, no API key needed)
full_results = TRUE
)
needs_geocoding %>%
select(pin, congregation_name, sample_lat, sample_lon) %>%
print()
needs_geocoding %>%
select(pin, congregation_name, sample_lat, sample_lon) %>%
needs_geocoding %>%
select(pin, congregation_name, sample_lat, sample_lon) %>%
print()
needs_geocoding <- unassigned_addresses %>%
filter(has_coords == 1) %>%
select(congregation_name, sample_lat, sample_lon)
print(needs_geocoding)
View(needs_geocoding)
View(unassigned_addresses)
# Get properties with coordinates but no addresses
needs_geocoding <- unassigned_addresses %>%
filter(!is.na(sample_lat) & !is.na(sample_lon))
View(needs_geocoding)
# Manual approach
library(httr)
library(jsonlite)
reverse_geo_osm <- function(lat, lon) {
if (is.na(lat) || is.na(lon)) return(NA_character_)
url <- paste0("https://nominatim.openstreetmap.org/reverse?",
"format=json&lat=", lat, "&lon=", lon,
"&zoom=18&addressdetails=1")
tryCatch({
response <- GET(url, user_agent("property_analysis@example.com"))
Sys.sleep(1.5)
if (status_code(response) == 200) {
result <- content(response, "parsed")
return(result$display_name)
}
return(NA_character_)
}, error = function(e) NA_character_)
}
geocoded_results <- needs_geocoding %>%
mutate(
geocoded_address = map2_chr(sample_lat, sample_lon, reverse_geo_osm)
)
geocoded_results %>%
select(congregation_name, num_unassigned, sample_lat, sample_lon, geocoded_address)
test_lat <- 37.53347
test_lon <- -76.79711
url <- paste0("https://nominatim.openstreetmap.org/reverse?",
"format=json&lat=", test_lat, "&lon=", test_lon,
"&zoom=18&addressdetails=1")
library(httr)
response <- GET(url, user_agent("property_analysis@example.com"))
# Check the response
print(status_code(response))
print(content(response, "parsed"))
library(tidygeocoder)
geocoded_results <- needs_geocoding %>%
reverse_geocode(
lat = sample_lat,
long = sample_lon,
method = "census",  # US Census Bureau (free, no blocking)
full_results = FALSE
)
geocoded_results <- needs_geocoding %>%
reverse_geocode(
lat = sample_lat,
long = sample_lon,
method = "arcgis",
full_results = FALSE
)
geocoded_results %>%
select(congregation_name, sample_lat, sample_lon, address)
# Save the geocoded addresses
write_csv(geocoded_results, "data/output/geocoded_unassigned_addresses.csv")
geocoded_results %>%
select(congregation_name, num_unassigned, cities, address) %>%
kable(
col.names = c("Congregation", "# Properties", "Cities", "Geocoded Address")
) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
needs_geocoding <- unassigned_addresses %>%
filter(!is.na(sample_lat) & !is.na(sample_lon))
View(needs_geocoding)
# Create a lookup table
address_lookup <- geocoded_results %>%
select(congregation_name, sample_lat, sample_lon, geocoded_address = address)
property_profile_updated <- property_profile %>%
left_join(address_lookup, by = c("congregation_name", "latitude" = "sample_lat", "longitude" = "sample_lon")) %>%
mutate(
sadd = if_else(is.na(sadd) | sadd == "", geocoded_address, sadd)
) %>%
select(-geocoded_address)
rlang::last_trace()
colnames(property_profile)
property_profile_updated <- property_profile %>%
left_join(address_lookup, by = c("congregation_name", "lat" = "sample_lat", "lon" = "sample_lon")) %>%
mutate(
sadd = if_else(is.na(sadd) | sadd == "", geocoded_address, sadd)
) %>%
select(-geocoded_address)
View(property_profile_updated)
write_csv(property_profile_updated, "data/output/property_profile_updated.csv")
shared_by_address <- property_profile_updated %>%
filter(!is.na(sadd) & sadd != "") %>%
group_by(sadd, scity) %>%
filter(n_distinct(congregation_name) > 1) %>%
arrange(sadd, congregation_name) %>%
select(sadd, scity, congregation_name, attendance_2023, uid, pid) %>%
ungroup()
View(shared_by_address)
View(shared_addresses)
View(property_profile_updated)
shared_by_address <- property_profile %>%
filter(!is.na(sadd) & sadd != "") %>%
group_by(sadd, scity) %>%
filter(n_distinct(congregation_name) > 1) %>%
arrange(sadd, congregation_name) %>%
select(sadd, scity, congregation_name, attendance_2023, uid, pid) %>%
ungroup()
shared_by_address_updated <- property_profile_updated %>%
filter(!is.na(sadd) & sadd != "") %>%
group_by(sadd, scity) %>%
filter(n_distinct(congregation_name) > 1) %>%
arrange(sadd, congregation_name) %>%
select(sadd, scity, congregation_name, attendance_2023, uid, pid) %>%
ungroup()
# Compare
nrow(shared_by_address_original)
# Compare
nrow(shared_by_address)
nrow(shared_by_address_updated)
incomplete_properties_updated <- property_profile_updated %>%
filter(
is.na(land_value) |
is.na(acreage) |
is.na(wetland_acres) |
is.na(flood_risk) |
is.na(qct) |
is.na(zoning) |
is.na(sadd) | sadd == ""
)
View(property_profile_updated)
incomplete_properties_updated <- property_profile_updated %>%
filter(
is.na(lan_val) |
is.na(acreage) |
is.na(wetland_acres) |
is.na(flood_risk) |
is.na(qct) |
is.na(zoning) |
is.na(sadd) | sadd == ""
)
View(property_profile_updated)
incomplete_properties_updated <- property_profile_updated %>%
filter(data_completeness < 6) %>%
arrange(data_completeness) %>%
select(congregation_name, data_completeness, sadd, scity, sstate, szip,
missing_land_value, missing_acreage, missing_wetland,
missing_flood, missing_qct, missing_zoning)
nrow(incomplete_properties)          # Old count: probably 121
nrow(incomplete_properties_updated)  # New count: should be lower!
View(data_followup)
missing_addresses_before <- property_profile %>%
filter(is.na(sadd) | sadd == "") %>%
nrow()
missing_addresses_after <- property_profile_updated %>%
filter(is.na(sadd) | sadd == "") %>%
nrow()
cat("Missing addresses before:", missing_addresses_before, "\n")
cat("Missing addresses after:", missing_addresses_after, "\n")
cat("Improvement:", missing_addresses_before - missing_addresses_after, "addresses added")
test_join <- property_profile %>%
left_join(address_lookup, by = c("congregation_name", "lat" = "sample_lat", "lon" = "sample_lon")) %>%
filter(!is.na(geocoded_address))
nrow(test_join)  # This will be 0 if no matches
address_lookup_simple <- geocoded_results %>%
select(congregation_name, geocoded_address = address)
property_profile_updated2 <- property_profile %>%
left_join(address_lookup_simple, by = "congregation_name") %>%
mutate(
sadd = case_when(
# Only update if address is missing AND this congregation has a geocoded address
(is.na(sadd) | sadd == "") & !is.na(geocoded_address) ~ geocoded_address,
TRUE ~ sadd
)
) %>%
select(-geocoded_address)
missing_addresses_after <- property_profile_updated2 %>%
filter(is.na(sadd) | sadd == "") %>%
nrow()
cat("Missing addresses after:", missing_addresses_after, "\n")
cat("Missing addresses before:", missing_addresses_before, "\n")
property_profile %>%
filter(congregation_name %in% c("St Johns Episcopal Church",
"St Pauls Church",
"St Stephens Church")) %>%
select(congregation_name, pin, sadd, lat, lon) %>%
print(n = 20)
property_profile %>%
filter(congregation_name %in% c("St Johns Episcopal Church",
"St Pauls Church",
"St Stephens Church")) %>%
select(congregation_name, sadd, lat, lon) %>%
print(n = 20)
property_profile %>%
filter(is.na(sadd) | sadd == "") %>%
count(congregation_name)
address_lookup_simple <- geocoded_results %>%
select(congregation_name, geocoded_address = address)
property_profile_updated <- property_profile %>%
left_join(address_lookup_simple, by = "congregation_name") %>%
mutate(
sadd = case_when(
# Replace if address contains "UNASSIGNED" and we have a geocoded address
str_detect(sadd, "UNASSIGNED") & !is.na(geocoded_address) ~ geocoded_address,
TRUE ~ sadd
)
) %>%
select(-geocoded_address)
property_profile_updated %>%
filter(congregation_name %in% c("St Johns Episcopal Church",
"St Pauls Church",
"St Stephens Church")) %>%
select(congregation_name, sadd, lat, lon) %>%
print(n = 20)
shared_by_address <- property_profile_updated %>%
filter(!is.na(sadd) & sadd != "") %>%
group_by(sadd, scity) %>%
filter(n_distinct(congregation_name) > 1) %>%
arrange(sadd, congregation_name) %>%
select(sadd, scity, congregation_name, attendance_2023, uid, pid) %>%
ungroup()
cat(sprintf("\nDifferent congregations at same address: %d addresses\n",
n_distinct(shared_by_address$sadd)))
cat(sprintf("Congregations affected: %d\n",
n_distinct(shared_by_address$congregation_name)))
View(shared_by_address)
View(property_profile_updated)
View(property_profile_updated)
duplicate_properties <- property_profile_updated %>%
group_by(congregation_name, sadd, lat, lon) %>%
filter(n() > 1) %>%
arrange(congregation_name, sadd, pin) %>%
select(congregation_name, sadd, pin, land_value, acreage, wetland_acres, lat, lon) %>%
ungroup()
duplicate_properties <- property_profile_updated %>%
group_by(congregation_name, sadd, lat, lon) %>%
filter(n() > 1) %>%
arrange(congregation_name, sadd) %>%
select(congregation_name, sadd, land_value, acreage, wetland_acres, lat, lon) %>%
ungroup()
colnames(property_profile_updated)
duplicate_properties <- property_profile_updated %>%
group_by(congregation_name, sadd, lat, lon) %>%
filter(n() > 1) %>%
arrange(congregation_name, sadd, pid) %>%
select(congregation_name, sadd, pid, lan_val, rgisacre, deed_acres, wet_perc, lat, lon) %>%
ungroup()
duplicate_summary <- property_profile_updated %>%
group_by(congregation_name, sadd, lat, lon) %>%
filter(n() > 1) %>%
summarise(
n_duplicate_entries = n(),
total_land_value = sum(lan_val, na.rm = TRUE),
total_gis_acreage = sum(rgisacre, na.rm = TRUE),
total_deed_acreage = sum(deed_acres, na.rm = TRUE),
pids = paste(pid, collapse = ", "),
.groups = "drop"
) %>%
arrange(desc(n_duplicate_entries))
duplicate_summary %>%
kable(
col.names = c("Congregation", "Address", "Lat", "Lon", "# Duplicate Entries",
"Total Land Value", "Total GIS Acreage", "Total Deed Acreage", "PIDs"),
digits = 2,
format.args = list(big.mark = ",")
) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
duplicate_summary <- property_profile_updated %>%
group_by(congregation_name, sadd, attendance_2023, plate_pledge_2023) %>%
filter(n() > 1) %>%
summarise(
n_entries = n(),
.groups = "drop"
) %>%
arrange(desc(n_entries))
duplicate_summary %>%
kable(
col.names = c("Congregation", "Address", "Attendance 2023", "Plate/Pledge 2023", "# Entries"),
digits = 0,
format.args = list(big.mark = ",")
) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
# Then separately show the data quality issue for one example
# Pick one congregation to illustrate the problem
property_profile_updated %>%
filter(congregation_name == "St Johns Episcopal Church",  # or whichever has most duplicates
sadd == "902 MAIN ST, WEST POINT 23181") %>%  # adjust address
select(pid, lan_val, rgisacre, deed_acres, zon) %>%
kable(
col.names = c("PID", "Land Value", "GIS Acreage", "Deed Acreage", "Zoning"),
caption = "Example: Multiple entries with different property data for the same congregation/address",
digits = 2,
format.args = list(big.mark = ",")
) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
library(tidyverse)
library(knitr)
library(kableExtra)
overlapping_parcels_summary <- property_profile_updated %>%
group_by(congregation_name, sadd) %>%
filter(n() > 1) %>%
summarise(
n_parcels = n(),
attendance_2023 = first(attendance_2023),
plate_pledge_2023 = first(plate_pledge_2023),
total_land_value = sum(lan_val, na.rm = TRUE),
total_gis_acreage = sum(rgisacre, na.rm = TRUE),
total_deed_acreage = sum(deed_acres, na.rm = TRUE),
pids = paste(pid, collapse = ", "),
.groups = "drop"
) %>%
arrange(desc(n_parcels))
overlapping_parcels_detail <- property_profile_updated %>%
group_by(congregation_name, sadd) %>%
filter(n() > 1) %>%
arrange(congregation_name, sadd, pid) %>%
select(congregation_name, sadd, scity, pid, uid,
lan_val, rgisacre, deed_acres, zon, zon_desc,
lat, lon, qct, fema_fz) %>%
ungroup()
View(overlapping_parcels_detail)
View(overlapping_parcels_summary)
total_congregations_with_overlap <- n_distinct(overlapping_parcels_summary$congregation_name)
total_overlapping_parcels <- sum(overlapping_parcels_summary$n_parcels)
max_parcels_per_congregation <- max(overlapping_parcels_summary$n_parcels)
cat("Overlapping Parcels Statistics:\n")
cat("  Congregations with multiple parcels:", total_congregations_with_overlap, "\n")
cat("  Total overlapping parcels:", total_overlapping_parcels, "\n")
cat("  Maximum parcels at one address:", max_parcels_per_congregation, "\n\n")
# Export summary
write_csv(overlapping_parcels_summary, "data/output/overlapping_parcels_summary.csv")
# Export detailed view
write_csv(overlapping_parcels_detail, "data/output/overlapping_parcels_detail.csv")
top_congregation <- overlapping_parcels_summary %>%
slice_max(n_parcels, n = 1)
cat("  Name:", top_congregation$congregation_name, "\n")
cat("  Address:", top_congregation$sadd, "\n")
cat("  Number of parcels:", top_congregation$n_parcels, "\n")
top_congregation_detail <- overlapping_parcels_detail %>%
filter(congregation_name == top_congregation$congregation_name,
sadd == top_congregation$sadd) %>%
select(pid, lan_val, rgisacre, deed_acres, zon_desc)
print(top_congregation_detail)
parcel_distribution <- overlapping_parcels_summary %>%
count(n_parcels, name = "n_congregations") %>%
arrange(n_parcels)
print(parcel_distribution)
